   Lecture Notes in Deep Learning: Loss and Optimization – Part 3
July 12, 2020
Optimization with ADAM and beyond...
These are the lecture notes for FAU’s YouTube Lecture “Deep Learning 2“. This is a full transcript of the lecture video & matching slides. We hope, you enjoy this as much as the videos. Of course, this transcript was created with deep learning tech‐ niques largely automatically and only minor manual modifications were performed. If you spot mistakes, please let us know!
 
 So far, we considered the optimisation mainly as straight-forward gradient descent method. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Welcome everybody to our next lecture on deep learning! Today, we want to talk about optimization. Let’s have a look at the gradient descent methods in a little bit more de‐ tail. So, we’ve seen that the gradient is essentially optimizing the empirical risk. Here in this figure, you see that we do one step each towards this local minimum. We have this predefined learning rate η. So, the gradient is of course computed with respect to every sample and this is then guaranteed to converge to a local minimum.
    
 Different sampling strategies for gradient descent. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Now, of course, this means that for every iteration, we have to use all samples and this is called batch gradient descent. So you have to look in every iteration, for every update, at all samples. It may be really many samples, in particular if you look at big data a computer vision problems. This is of course a preferred option for convex opti‐ mization problems because we have a guarantee here that we find the global mini‐ mum. Every update is guaranteed to decrease the error. Of course, for non-convex problems, we have a problem anyway. Also, we may have memory limitations. This is why people like to prefer other approaches like the stochastic gradient descent SGD. Here, they use just one sample and then immediately update. So, this is no longer nec‐ essarily decreasing the empirical risk in every iteration and it may also be very ineffi‐ cient because of the latency in transfers to the graphical processing unit. However, if you use just one sample you can do many things in parallel so it’s highly paralleliz‐ able. A compromise between the two is that you can use Mini-Batch stochastic gradi‐ ent descent. Here you use B and B may be a number much smaller than the entire training data set of random samples that you essentially choose them randomly from the entire training data set. Then, you evaluate the gradient on the subset B. This is then called a mini-batch. Now, this mini-batch can be evaluated really quickly and you may also use parallelization approaches and because you can do several mini-batch steps in parallel. Then, you just do the weighted sum and update. So, small batches are useful because they offer a kind of regularization effect. This then typically results in smaller η. So, you have if you use a mini-batch in gradient descent, typically smaller
   
 values of η are sufficient and it also regains efficiency. Typically, this is the standard case in deep learning.
Possible reasons why deep learning works so well. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
So, a lot of people work with this, meaning that the gradient descent is effective. But the question is: “How can this even work?” Our optimization problem is non-convex. There’s an exponential number of local minima and there’s an interesting paper from 2015 and where they show that the metrics that we are typically working with are high dimensional functions. There are many local minima in this environment. The interest‐ ing thing is that those local minima are close to the global minimum and actually many of those are equivalent. What is probably more of a problem are saddle points. Also, the local minima might even be better than the global minimum because the global minimum is attained on your training set, but in the end, you want to apply your network to a test data set that may be different. Actually, a global minimum on your training data set may be related to an overfit. Maybe, this is even worse for the gener‐ alization of the trained network.
    
 Overprovisioning might be an answer to the effectiveness of deep neural networks. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
One more possible answer to this is a paper from 2016. The authors are suggesting over-provisioning as there are many different ways of how a network can approximate the desired relationship. You essentially just need to find one. You don’t need to find all of them. A single one is sufficient. Liang at al. verified this experimentally by experi‐ ments with random labels. Here, the idea is that you essentially randomize the labels you don’t use the original. You just randomly assign any classes and if you then show that your experiment still solves the problem, then you are creating an overfit.
    
 The choice of η is crucial for successful learning. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Let’s have a look at the choice of η. What we’ve already seen that if you have a small learning rate, we may stop even before we reach convergence. If you have a too large learning rate, we might be ending jumping back and forth and not even finding the lo‐ cal minimum. Only with an appropriate learning rate, you will be able to find the mini‐ mum. Actually, when you’re far away from the minimum, you want to be able to make big steps, and the closer you get to the minimum smaller steps. If you want to do so in practice, you work with the decay of the learning rate. So, you adapt your η gradually. You start with let’s say 0.01 and then you divide by ten every x epochs. This helps that you don’t miss the local minimum that you’re actually looking for. It’s a typical practi‐ cal engineering parameter.
    
 Can we get rid of our “engineering parameter” η? Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Now, you may ask can’t we get rid of this magic η? So what is typically done? Quite a few people suggest doing a line search in similar cases. So, line search of course needs you to estimate the optimal η at every step. So, you need multiple evaluations in order to find the correct η in the direction that the gradient points. It is extremely noisy anyway. So, people have presented methods but they are not the state of the art right now in deep learning. Then, people have suggested second-order methods. If you look into second-order methods, you need to compute the Hessian matrix and this is typically very expensive to calculate. So far, we have not seen that too often. There are L-BFGS methods but they typically don’t perform very well if you are operat‐ ing outside of the batch setting. So, if you work with mini-batches, they are not that great. There’s a report on that by Google that you can find in reference [7].
    
 Can we improve our noisy gradient descent using persistent directions? Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
What else can we do? Well, of course, we could accelerate the directions of persistent gradients. So, the idea here would be that you somehow keep track of the average that is indicated here with new v. This is essentially a weighted sum over the last cou‐ ple of gradient steps. You take the current gradient direction indicated in red and aver‐ age it with the previous steps. This then gives you an updated direction and this is typ‐ ically called a momentum.
    
 A formal definition of the momentum term. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
So, we introduce this momentum term. There you add with a new weight some mo‐ mentum that is indicated with v superscript k-1. This momentum term is essentially computed in an iterative fashion where you iteratively update over the past gradient directions. So you can essentially say by iteratively computing this weighted mean, you keep a history of the previous gradient directions and you gradually update them with the new gradient direction. Then you pick the momentum term in order to per‐ form the update instead of just the gradient direction. So, typical choices for μ are 0.9, 0.95, or 0.99. You can also adapt them from small to large if you want them to pay more emphasis on the previous gradient directions. This overcomes poor Hessians and variance in the stochastic gradient descent. It will dampen oscillations and it ac‐ celerates typically the optimization procedures. Still, we need the learning rate decay. So, this doesn’t solve the automatic adjustment of η.
    
 Nesterov Momentum tries to predict the momentum term. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
We can also pick a different way of momentum: the Nesterov Accelerated Gradient or simply Nesterov Momentum. This performs a look-ahead. So here, we also have this momentum term. But instead of evaluating the gradient at the position we’re currently at, we add the momentum term before computing the gradient. So, we are essentially trying to approximate the next set of parameters. We use the look-ahead it here and then we perform the gradient update. So you can rewrite this to use the conventional gradient. The idea here is to put the Nesterov Acceleration directly into the gradient update. This term will then be used in the next gradient update. So, this is an equiva‐ lent formulation.
    
 Momentum and Nesterov Momentum in Comparison. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Let’s visualize this a bit. Here, you can see momentum and the Nesterov Momentum. Of course, they both use a kind of momentum term. But they use a different direction for calculating the gradient update. That’s the main difference.
    
 In this example, you can see the strength of the Nesterov Momentum term. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Here, you see an example of these momentum terms in comparison. In this situation, you have a strong disagreement in the variance in both directions. So, we have a very high variance in left and right directions and a rather small variance in the top-bottom direction. We’re trying to find the global minimum. This then leads typically to alternat‐ ing gradient directions very strongly even if you introduce the momentum term. You still get this strong oscillating behavior. If you use the Nesterov Accelerated Gradient, you can see that we compute this look-ahead and this allows us to follow the blue line. So, we are directly moving towards the desired minimum and we are no longer al‐ ternating. This is an advantage of Nesterov.
    
 Some parameters may have different updates than others. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
What if our features have different needs? So, suppose some features are activated very infrequently while others are updated very often. Then, we would need individual learning rates for every parameter in the network. We need large learning rates for in‐ frequent parameters and small learning rates for frequent parameters.
    
 AdaGrad introduces individual scaling for each parameter. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
In order to accommodate the changes appropriately, this can be done with the so- called AdaGrad method. It is using first the gradient to compute some g superscript k and then it’s computing the product of the gradient with itself to keeps track of its ele‐ ment-wise variance in a variable r. Now, we use our g and our r elementwise as in combination with η to weigh the update of the gradient. So, now we construct updated weights and the variance of the weights in every parameter is incorporated by multi‐ plying with the square root of the respective element, i.e. an approximation of its stan‐ dard deviation. So, here we note this down as a square root of an entire vector. All the other things here are scalar which means that this also results in a vector again. This vector is then multiplied point-wise with the actual gradient to perform a local scaling. It’s a nice and efficient method and allows individual learning rates for all of the differ‐ ent dimensions for all of the different weights. One problem could be that the learning rate decreases too aggressively.
    
 RMSProp builds on AdaGrad. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
This is a problem and leads to an improved version and the improved version here is RMSProp. RMSProp is now using this again, but they introduce this ρ and now ρ is be‐ ing used to essentially introduce a delay such that you don’t have very high increases. Here you can set this ρ in order to dampen the update of the variance of the learning rate. So, Hinton suggests 0.9 and η = 0.001. This turn leads to the aggressive de‐ crease being fixed, but we still have to set the learning rate. If you don’t set the learn‐ ing rate appropriately, you run into a problem.
     
 Adadelta gets rid of η. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Now, Adadelta tries to improve on this further. They use essentially our RMSProp and get rid of η. So, we already have seen r. It is the variance that is computed in a damp‐ ened way. Then, in addition, they introduce this Δx. It is a weighted combination of some term h and the r that we have seen previously multiplied to the gradient direc‐ tion. So, this is an additional dampening factor that replaces the η in the original for‐ mulation. The factor h is computed again as a sliding average over the Δx as an ele‐ ment-wise product. So, this way you don’t have to set a learning rate anymore. Still, you have to choose the parameter ρ. For ρ we suggest going to 0.95.
    
 Adam builds on Adadelta using an additional momentum term v. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
One of the most popular algorithms that are being used is Adam and Adam is essen‐ tially also using this gradient direction g. Then, you have essentially a momentum term v. In addition, you have this r term that is again trying to steer the learning rate for each dimension individually. Furthermore, Adam introduces an additional bias cor‐ rection where v is scaled by 1 minus μ. r is also scaled by 1 over 1 minus ρ. This then leads to the final update term that involves the learning rate η, our momentum term, and the respective scaling. This algorithm is called Adaptive Moment estimation. For Adam suggested values are μ = 0.9, ρ = 0.999 and η=0,001. It’s a very robust method and very commonly used. We can combine it with the Nesterov accelerated gradient and you get “Nadam”. But still, you can improve on this.
   
 AMSGrad fixes the convergence problem in Adam. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Adam was empirically observed to fail to converge to optimal/good solutions. In refer‐ ence [5], you can even see that Adam and similar methods do not guarantee to con‐ verge for convex problems. There’s an error in the original convergence proof and therefore, we suggest using AMSGrad that fixes Adam to ensure non increasing step size. So, you can fix it by adding a maximum over the momentum update term. So if you do this, you result in AMSGrad. This is shown to be even more robust. The effect has been shown in large experiments. One lesson that we learn here is that you should keep your eyes open. Even things that go through scientific peer review may have problems that are later identified. Another thing that we learned here is that these gradient descent procedures – as long as you approximately follow the correct gradient direction – you still get quite decent results. Of course, such gradient meth‐ ods are really hard to debug. So, be sure that you debug your gradients. This really happens as you can see in this example. Even large software frameworks may suffer from such errors. For a long time, people didn’t notice them. They just notice strange behavior, but the problem persists.
    
 Summary of today’s lecture. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Okay, so let’s summarize this a bit. The stochastic gradient descent plus Nesterov momentum plus learning rate decay is a typical choice in many experiments. It con‐ verges most reliably and is used in many state-of-the-art papers. Still, it has the prob‐ lem that this learning rate decay has to be adjusted. Adam has individual learning rates. The learning rates are very well-behaved, but of course, the loss curves are much harder to interpret because you don’t have this typical behavior as you would see with fixed learning rates. What we didn’t discuss here and we only hinted at that is distributed gradient descent. Of course, you can also do this in a parallelized manner and then compute different update steps in different nodes of a distributed network or on different graphic boards. Then you average over them. This has also been shown to be very robust and very fast.
     
 Practical recommendations for your work. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Some practical recommendations: Start by using mini-batch stochastic gradient de‐ scent with momentum. Stick to the default momentum. Give Adam a try when you have a feeling for your data. When you see that you need individual learning rates then Adam can help you with getting better or more stable convergence. You can also switch to AMSGrad which is an improvement over Adam. Of course, start adjusting the learning rate first and then keep your eyes open regarding unusual behavior.
    
 More exciting things coming up in this deep learning lecture. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Okay, this brings us to a short outlook on the next couple of videos and what we are coming up with. Of course the actual deep learning part, we haven’t discussed this at all so far. So one problem that we still need to talk about is how can we deal with spa‐ tial correlation and features. We hear so much about convolution and neural net‐ works. Next time we see why this is a good idea how is it implemented. Of course, one thing that we should think about is how to use variances and how to incorporate them into network architectures.
   
 Questions that may help to prepare for the exam. Image under CC BY 4.0 3 from the Deep Learning Lecture 2.
Some comprehensive questions: “What are our standard loss functions for classifica‐ tion and regression?” So of course, L2 for regression and cross-entropy loss for clas‐ sification. You should be able to derive those. This is really something that you should know because the statistics and their relations to learning losses are really important. The statistical assumptions, probabilistic theory, and how to modify those to get to our loss functions are highly relevant for the exam. Very important are also subdiffer‐ entials. “What’s a subdifferential?” “How can we optimize in situations where our acti‐ vation functions have a kink?” “What’s the hinge loss?” “How can we incorporate con‐ straints?” and in particular “What do we tell people that claim that all our techniques are not good because an SVM is superior?” Well, you can always show that it’s up to a multiplicative constant the same as using hinge loss. “What is Nesterov Momentum?” These are very typical things you should be able to explain if somebody in the near fu‐ ture is going to ask you questions about the things that you have been learning here. Of course, we have plenty of references again (see below). I hope you enjoyed this lec‐ ture as well and I am looking forward to seeing you in the next one!
If you liked this post, you can find more essays here 4, more educational material on Machine Learning here 5, or have a look at our Deep 6Learning 2 Lecture 6. I would also appreciate a clap or a follow on YouTube 7, Twitter 8, Facebook 9, or LinkedIn 10 in case you want to be informed about more essays, videos, and research in the future. This
          
article is released under the Creative Commons 4.0 Attribution License 11 and can be reprinted and modified if referenced.

 
